<!DOCTYPE html>
<html lang="en">
<head>
  <title>XYZ Explorer</title>
  <meta property="og:description" content="XYZ Explorer." />
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@5.4.0/dist/maplibre-gl.css' />
  <script src='https://unpkg.com/maplibre-gl@5.4.0/dist/maplibre-gl.js'></script>
  <style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    #layer-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 10px;
      z-index: 1;
      font-family: sans-serif;
      font-size: 14px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    </style>
</head>

<body>
  <div id="layer-controls" style="position:absolute; top:10px; left:10px; background:white; padding:10px; z-index:1;">
    <strong>View Mode:</strong><br>
    <label><input type="radio" name="layer-toggle" value="hexbins"> Hexbins</label><br>
    <label><input type="radio" name="layer-toggle" value="quadbins"> Quadbins</label><br>
    <label><input type="radio" name="layer-toggle" value="centroids"> Centroids</label>
  </div>

  <div id="map"></div>
  <script>
    let spaceID = 'stXc82l8';
    let hubApi = 'api.think-with-me.com';
    let clustering, rez; 

    // check to see if we have clustering options in the urlParams
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('space')) spaceID = urlParams.get('space');
    if (urlParams.get('hubApi')) hubApi = urlParams.get('hubApi');
    if (urlParams.get('clustering')) {
        clusteringParam = urlParams.get('clustering');
      
    // valid clustering types are hexbin ( h3) and quadbin -- normalize params (and provide a shortcut for h3 centroids)
    if (urlParams.get('clustering')) {
      clusteringParam = urlParams.get('clustering');
      if (clusteringParam === 'quadbin') {
        clustering = 'quadbin'}
      if (clusteringParam === 'h3' || 'hexbin') {
        clustering = 'hexbin'}
      if (clusteringParam === 'h3_centroid' || 'centroid') {
        clustering = 'centroid'}
      if (urlParams.get('rez')) {
        if (Number.isInteger(urlParams.get('rez'))){
          if (rez <= 3 && rez >= -3){
            rez = urlParams.get('rez')
          } else {
            rez = '';
            console.log("relative rez of",urlParams.get('rez'),"is a bad idea, keep it between 2 and -2")
          }
        } else {
          rez = '';
          console.log("rez has to be an integer, unlike",urlParams.get('rez'))
        } 
      }
    }
    console.log("url params",{spaceID},{hubApi},{clustering},{rez});


    function build_xyz_url(clusterType){

      let xyz_url = `https://${hubApi}/hub/spaces/${spaceID}/tile/web/{z}_{x}_{y}.mvt?clip=true`;
      // note that protomaps / maplibre doesn't support geojson tiles as a source, just mvt...
      // this introduces a significant issue as nested properties are presented as strings 
      // and mapbox/libre expressions can't parse them...
      
      // might have a cluster param from reloadLayer or might be getting it from urlParams
      // could check clustering global or clusterType function parameter better?
      // will need to be able to change these xyz url paramas later if we add more clustering options 
      // wanted to use URLSearchParams but need to figure out how to handle hubApi and spaceID and {z}_{x}_{y} in xyz_url path..

      var xyz_quadbin = '&clustering=quadbin&clustering.countmode=mixed&clustering.relativeResolution=4';
      var xyz_hexbin = '&clustering=hexbin';
      var xyz_centroid = '&clustering=hexbin&clustering.pointmode=true';
      
      if(clusterType){
        if (clusterType === 'quadbin') {
          xyz_url += xyz_quadbin};
        if (clusterType == 'hexbin') {
          xyz_url += xyz_hexbin};
        if (clusterType === 'centroid') {
          xyz_url += clustering_centroid};
        xyz_url += xyz_centroid;
  
        if ('rez') {
          rez = urlParams.get('rez');
          xyz_url += '&clustering.relativeResolution=' + rez;
        }
      }
      console.log({xyz_url})
      return xyz_url
    }

    const styleUrl = 'https://api.protomaps.com/styles/v5/white/en.json?key=ffc24a4325d458ce';
    const map = new maplibregl.Map({
      container: 'map',
      hash: true,
      style: styleUrl,
      zoom: 13,
      center: [-122.447303, 37.753574]
    });

    // even after 10 years mapbox/libre expressions still cannot handle a nested object in a vector tile source, so we need to parse the string
    // this assumes a quoted key and a numeric value
  
    
    // annoying to have to convert from a string in the other expressions so providing number and string options...
    const get_nested_number = [
      "to-number", [
        "slice",
        ["get", "aggregation"],
        ["+", ["index-of", ":", ["get", "aggregation"]], 2],
        ["-", ["length", ["get", "aggregation"]], 1]
      ]
    ];

    const get_nested_value = [
        "slice",
        ["get", "aggregation"],
        ["+", ["index-of", ":", ["get", "aggregation"]], 2],
        ["-", ["length", ["get", "aggregation"]], 1]
    ];

      
    const hexbin_clamped_log_nested_aggregation = [
      "case",
      ["<", ["index-of", ":", ["coalesce", ["get", "aggregation"], ""]], 0], 0,
      ["<", ["log2", ["to-number", ["slice", ["get", "aggregation"], ["+", ["index-of", ":", ["get", "aggregation"]], 2], ["-", ["length", ["get", "aggregation"]], 1]]]], 0], 0,
      [">", ["log2", ["to-number", ["slice", ["get", "aggregation"], ["+", ["index-of", ":", ["get", "aggregation"]], 2], ["-", ["length", ["get", "aggregation"]], 1]]]], 20], 20,
      ["log2", ["to-number", ["slice", ["get", "aggregation"], ["+", ["index-of", ":", ["get", "aggregation"]], 2], ["-", ["length", ["get", "aggregation"]], 1]]]]
    ];

    const clamped_log_count = [
      "case",
      ["<", ["log2", ["coalesce", ["get", "count"], 1]], 0], 0,
      [">", ["log2", ["coalesce", ["get", "count"], 1]], 20], 20,
      ["log2", ["coalesce", ["get", "count"], 1]]
    ];


    // various dataviz color ramp experiments, need to figure out how to bring in colorbrewer

    const red_log_clamped_hexbin_ramp = [
      "interpolate", ["linear"],
      hexbin_clamped_log_nested_aggregation,
      0, "#fee5d9",
      6, "#fcae91",
      12, "#fb6a4a",
      16, "#de2d26",
      20, "#a50f15"
    ];

    const red_log_quadbin_ramp = [
      "interpolate", ["linear"],
      clamped_log_count,
      0, "#fee5d9",
      6, "#fcae91",
      12, "#fb6a4a",
      16, "#de2d26",
      20, "#a50f15"
    ];

    // defining styles -- theses are cluster specific, need to define generic polygon / point / line layers for xyz spaces later
    const xyzLayers = {
      hexbins: {
        id: 'hexbins',
        type: 'fill',
        source: 'xyz',
        'source-layer': spaceID,
        paint: {
          'fill-color': red_log_clamped_hexbin_ramp,
          'fill-opacity': 0.3
        },
        filter: [
          "all",
          ["==", "$type", "Polygon"],
          ["==", "kind", "H3"]
        ]
      },
      quadbins: {
        id: 'quadbins',
        type: 'fill',
        source: 'xyz',
        'source-layer': spaceID,
        paint: {
          'fill-color': red_log_quadbin_ramp,
          'fill-opacity': 0.3
        },
        filter: [
          "all",
          ["==", "$type", "Polygon"],
          ["has", "qk"]
        ]
      },
      centroids: {
        id: 'centroids',
        type: 'circle',
        source: 'xyz',
        'source-layer': spaceID,
        paint: {
          'circle-radius': ["+", 6, ["log2", get_nested_number]],
          'circle-color': red_log_clamped_hexbin_ramp,
          'circle-opacity': 0.2,
          'circle-stroke-width': 1,
          'circle-stroke-color': '#000000',
          'circle-stroke-opacity': 0.5
        },
        filter: [
          "all",
          ["==", "$type", "Point"],
          ["==", "kind", "H3"]
        ]
      },
      labels: {
        id: 'bin-labels',
        type: 'symbol',
        source: 'xyz',
        'source-layer': spaceID,
        layout: {
          "text-ignore-placement": true,
          "symbol-placement": "point",
          "text-field": ["coalesce",["get", "count"], get_nested_value,], // generic label for both hexbin and quadbin
          // "text-field":  ["to-string", get_nested_number],
          "text-size": 10,
          "text-justify": "center",
          "text-font": ["Noto Sans Regular"],
          "text-variable-anchor": ["center", "top", "bottom", "left", "right"]
        },
        paint: {
          "text-color": "#000",
          "text-halo-color": "#fff",
          "text-halo-width": 1.5
        },
        filter: [
          "any",
          ["==", "kind", "H3"],
          ["has", "qk"]
        ]
      },
      outlines: {
        id: 'outlines',
        type: 'line',
        source: 'xyz',
        'source-layer': spaceID,
        paint: {
          'line-color': '#cccccc',
          'line-width': 1
        },
        filter: ['==', '$type', 'Polygon']
      }
    };

    // map.on('error', (e) => {
    //     console.log('ERROR', e);
    // });
      
    map.on('load', () => {
      console.log('using URL with',{clustering})
      loadXYZSource(clustering)
      //keeping for reference
      // Object.values(xyzLayers).forEach(layer => {
      //   map.addLayer(layer, firstSymbolId);
      //   map.setLayoutProperty(layer.id, 'visibility', 'none');
      // });
      // toggleToLayer('hexbins');


      document.querySelectorAll('input[name="layer-toggle"]').forEach(input => {
        input.addEventListener('change', event => {
          clustering = event.target.value;
          reloadLayer(clustering);
        });
      });

    });
      
    // keeping for reference
    function toggleToLayer(selectedId) {
      Object.values(xyzLayers).forEach(layer => {
        if (map.getLayer(layer.id)) {
          map.setLayoutProperty(layer.id, 'visibility', 'none');
        }
      });

      if (map.getLayer(xyzLayers.outlines.id)) {
        map.setLayoutProperty(xyzLayers.outlines.id, 'visibility', 'visible');
      }

      const mainLayer = xyzLayers[selectedId];
      if (mainLayer) {
        map.setLayoutProperty(mainLayer.id, 'visibility', 'visible');
      }

      if (map.getLayer(xyzLayers.labels.id)) {
        map.setLayoutProperty(xyzLayers.labels.id, 'visibility', 'visible');
      }
    }

    function loadXYZSource(clusterType) {
      // figure out where basemap labels are so we can put dataviz under (I will die on this hill)
      const layers = map.getStyle().layers;
      let firstSymbolId;
      for (let i = 0; i < layers.length; i++) {
        if (layers[i].type === 'symbol') {
          firstSymbolId = layers[i].id;
          break;
        }
      }
      const layer = xyzLayers[clusterType];
      // if (!layer) return; // this may cause problems -- what if we just want to inspect the xyz space w/o clustering
    
      // Remove old source and layer
      if (map.getLayer(layer.id)) {
        map.removeLayer(layer.id);
      }
      if (map.getSource('xyz')) {
        map.removeSource('xyz');
      }
      tile_url = build_xyz_url(clusterType)
      map.addSource('xyz', {
        type: 'vector',
        tiles: [tile_url]
      });

      if (clusterType == 'hexbin'){
        map.addLayer(xyzLayers.hexbins, firstSymbolId);
      }
      if (clusterType == 'quadbin'){
      map.addLayer(xyzLayers.quadbins, firstSymbolId);
      }
      if (clusterType == 'centroid'){
        map.addLayer(xyzLayers.centroids, firstSymbolId);
      }      
      // probably need to handle rez
      map.addLayer(xyzLayers.labels, firstSymbolId);
      map.addLayer(xyzLayers.outlines, firstSymbolId);

    }
  </script>
</body>
</html>
